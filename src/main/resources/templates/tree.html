<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org" xmlns:sec="http://www.w3.org/1999/xhtml" lang="ru">
<head>
    <meta charset="utf-8" />
    <title>Генеалогическое древо — Cytoscape</title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"/>

    <!-- cytoscape + dagre -->
    <script src="https://unpkg.com/cytoscape@3.24.0/dist/cytoscape.min.js"></script>
    <script src="https://unpkg.com/dagre@0.8.5/dist/dagre.min.js"></script>
    <script src="https://unpkg.com/cytoscape-dagre@2.3.2/cytoscape-dagre.js"></script>
    <script th:src="@{/js/tree_vis.js}"></script>

    <style>
        body { background: #FAF6F0; color: #3B2F2F; font-family: "Segoe UI", sans-serif; }
        #cy { width: 100%; height: 78vh; background: #fff; border-radius: 10px; border:1px solid #D9825B; }
        .legend { margin-top: 8px; }

        /* node card styling (Cytoscape uses SVG/text — styling here is for nodes via style section) */
    </style>
</head>
<body>

<div th:replace="~{fragments/navbar :: navbar}" sec:authorize="isAuthenticated()"></div>

<div class="container mt-4">
    <h2 class="text-center mb-3">Генеалогическое древо (Cytoscape)</h2>

    <div id="cy" class="shadow-sm"></div>

    <div class="legend text-center small">
        <span style="display:inline-block; padding:6px 10px; border-radius:6px; border:1px solid #7C8B60; background:#FAF6F0; margin-right:8px;">Мужчина</span>
        <span style="display:inline-block; padding:6px 10px; border-radius:6px; border:1px solid #D9825B; background:#fff;">Женщина</span>
    </div>
</div>

<script type="module">
    import { Network } from "https://cdn.jsdelivr.net/npm/vis-network/standalone/esm/vis-network.min.js";

    document.addEventListener("DOMContentLoaded", async () => {
      const container = document.getElementById("cy");
      container.style.height = "90vh";
      container.style.border = "2px solid #D9825B";
      container.style.borderRadius = "12px";
      container.style.backgroundColor = "#FAF6F0";

      const response = await fetch("/api/tree");
      if (!response.ok) {
        container.innerHTML = "<div class='p-3 text-danger'>Ошибка загрузки /api/tree</div>";
        return;
      }

      const people = await response.json();
      const byId = Object.fromEntries(people.map(p => [p.id, p]));

      // безопасный парсинг даты
      const ts = d => {
        const t = new Date(d).getTime();
        return isNaN(t) ? Infinity : t;
      };

      // --- узлы ---
      const nodes = people.map(p => ({
        id: p.id,
        label: `${p.firstName || ""} ${p.lastName || ""}\n${p.birthDate || ""}`,
        color: {
          background: p.gender === "FEMALE" ? "#F8DAD1" : "#E1E9D2",
          border: p.gender === "FEMALE" ? "#D9825B" : "#7C8B60"
        },
        font: { color: "#3B2F2F", size: 14 },
        shape: "box",
        margin: 10,
        borderWidth: 2,
        birthTs: ts(p.birthDate)
      }));

      // --- связи ---
      const edges = [];
      for (const p of people) {
        if (p.fatherId && byId[p.fatherId]) edges.push({ from: p.fatherId, to: p.id });
        if (p.motherId && byId[p.motherId]) edges.push({ from: p.motherId, to: p.id });
        if (p.spouseId && byId[p.spouseId]) {
          const a = p.id, b = p.spouseId;
          if (!edges.some(e => (e.from === a && e.to === b) || (e.from === b && e.to === a)))
            edges.push({ from: a, to: b, dashes: [4, 4], color: "#4A5C6A" });
        }
      }

      // --- определяем поколения по датам ---
      // группируем людей по десятилетиям рождения, чтобы старшие были выше
      const groups = {};
      for (const p of people) {
        const year = new Date(p.birthDate).getFullYear();
        const bucket = isNaN(year) ? 9999 : Math.floor(year / 10) * 10;
        if (!groups[bucket]) groups[bucket] = [];
        groups[bucket].push(p);
      }

      // сортируем группы по возрастанию возраста (меньше год — ниже)
      const sortedBuckets = Object.keys(groups)
        .map(y => parseInt(y))
        .sort((a, b) => a - b); // старшие (меньше год) будут раньше — выше

      const coords = new Map();
      const genStepY = 300; // расстояние между поколениями
      const stepX = 280;    // горизонтальное расстояние между людьми

      sortedBuckets.forEach((bucket, lvl) => {
        const group = groups[bucket];
        group.sort((a, b) => ts(a.birthDate) - ts(b.birthDate));
        const total = group.length;
        const startX = -((total - 1) * stepX) / 2;

        group.forEach((p, i) => {
          const x = startX + i * stepX;
          const y = lvl * genStepY;
          coords.set(p.id, { x, y });
        });
      });

      // --- супруги рядом ---
      for (const p of people) {
        if (p.spouseId && coords.has(p.id) && coords.has(p.spouseId)) {
          const a = coords.get(p.id), b = coords.get(p.spouseId);
          const mid = (a.x + b.x) / 2;
          const offset = 160; // увеличенное расстояние между супругами
          coords.set(p.id, { x: mid - offset, y: a.y });
          coords.set(p.spouseId, { x: mid + offset, y: b.y });
        }
      }

      // --- создаём сеть ---
      const network = new Network(container, { nodes, edges }, {
        physics: false,
        edges: { smooth: { type: "cubicBezier" }, color: "#7C8B60" },
        interaction: { hover: true, zoomView: true, dragView: true }
      });

      // --- позиционирование после отрисовки ---
      network.once("afterDrawing", () => {
        coords.forEach((pos, id) => network.moveNode(id, pos.x, pos.y));
        network.fit({ animation: true, padding: 150 });
      });
    });
</script>



</body>
</html>
